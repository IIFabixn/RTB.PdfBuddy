@page "/editor"
@using Microsoft.AspNetCore.Components.Sections
@using PdfSharpCore.Drawing
@using PdfSharpCore.Pdf
@using PdfSharpCore.Pdf.IO
@using RTB.BlazorUI.Extensions
@using Microsoft.AspNetCore.Components.Forms
@using RTB.BlazorUI.Services.BusyTracker
@using RTB.BlazorUI.Services.DataNavigationService
@using RTB.BlazorUI.Services.Dialog
@using RTB.BlazorUI.Services.DragDrop.Components
@using RTB.PdfBuddy.Web.Extensions
@using System.Net.Mime

@inject ILogger<Editor> Logger
@inject IJSRuntime JSRuntime
@inject DataNavigationService DataNavigationService
@inject BusyTracker BusyTracker
@inject IDialogService DialogService

@inherits RTBComponent

<Grid FullHeight Rows="1fr auto" class="gap-4">
    <GridItem Row="1" class="min-w-0 min-h-0 overflow-auto">
        <CollectionList IsVertical FullHeight Items="@Files" TItem="PdfDocument" Context="file" class="gap-4">
            <ItemTemplate>
                <FlexLayout IsVertical class="gap-2">
                    <FlexLayout IsHorizontal class="gap-2 items-center">
                        <button class="text-red-300 px-0.5 self-end cursor-pointer" @onclick="() => RemoveFile(file)">x</button>
                        <div class="grow overflow-auto">
                            <input type="text max-w-full"
                            class="border-b min-w-xs outline-none px-1 self-start max-w-full"
                            placeholder="File name"
                            style="field-sizing: content;"
                            @bind-value="file.Info.Title" />
                        </div>
                        <button class="justify-self-end">Save</button>
                    </FlexLayout>
                    <FlexLayout IsHorizontal class="gap-1 overflow-auto scrollbar">
                        @for (var pageIndex = 0; pageIndex < file.PageCount; pageIndex++)
                        {
                            var capturedIndex = pageIndex;
                            var capturedPage = file.Pages[capturedIndex];
                            <DropZone class="h-full min-w-2 rounded" DraggingClass="bg-blue-100" TObject="PdfPage[]" OnObjectDropped="pages => MovePageToFileAtIndex(file, capturedIndex, pages)" />

                            <DraggableItem TData="PdfPage[]" ItemData="@(SelectedPages.Contains(capturedPage) ? SelectedPages.ToArray() : new[] { capturedPage })">
                                <FlexLayout @onclick="() => ToggleSelection(capturedPage)" IsVertical class="@($"{(SelectedPages.Contains(capturedPage) ? "border-red-400" : "border-white")} group h-24 text-xs border-2 rounded-tr flex flex-col justify-center w-16 overflow-clip relative")">
                                    <div class="absolute top-1 right-1 collapse group-hover:visible">
                                        <button type="button" class="w-4 rounded h-4 bg-white shadow text-red-400 grid content-center leading-0 align-middle" @onclick="@(() => RemovePageFromFile(file, capturedPage))">
                                            x
                                        </button>
                                        <button type="button" class="w-4 rounded h-4 bg-white shadow text-red-400 grid content-center leading-0 align-middle" @onclick="() => ShowFullscren(capturedPage)">
                                            O
                                        </button>
                                    </div>
                                    <PdfViewer Page="capturedPage" class="border" />
                                </FlexLayout>
                            </DraggableItem>
                        }
                        <!-- Drop after the last page -->
                        <DropZone class="h-full min-w-2 grow" TObject="PdfPage[]" OnObjectDropped="(page) => MovePageToFileAtIndex(file, file.PageCount - 1, page)" />
                    </FlexLayout>
                </FlexLayout>
            </ItemTemplate>
        </CollectionList>
    </GridItem>
    <GridItem Row="2">
        <FlexLayout IsHorizontal class="gap-2 items-center">
            <DropZone class="grow" TObject="PdfPage[]" OnObjectDropped="@(pages => MovePagesToNewFile(pages))">
                <FileDropInput Id="EditorNewDocumentDropArea" Multiple OnInput="FileAdded"
                               AcceptedTypes="@(new[] { MediaTypeNames.Application.Pdf })">
                    <div class="border rounded min-h-18 flex flex-col p-2 justify-center text-gray-400 text-sm">
                        <p class="max-w-lg">
                            Create New Document by dragging pages of existing files into here or
                            import new files by dragging them into here
                        </p>
                    </div>
                </FileDropInput>
            </DropZone>
            <FlyoutMenu Position="FlyoutMenu.FlyoutPosition.Up">
                <Activator>
                    <div class="w-12 h-12 grid place-items-center"><span>[+]</span></div>
                </Activator>
                <ChildContent>
                    <FlexLayout IsVertical class="gap-1 p-2 **:hover:text-red-400 *:cursor-pointer">
                        <button type="button" @onclick="SplitAll">
                            <span class="text-black">Split</span>
                        </button>
                        <button type="button" @onclick="MergeAll">
                            <span class="text-black">Merge</span>
                        </button>
                        <button type="button">
                            <span class="text-black whitespace-nowrap">Save All</span>
                        </button>
                    </FlexLayout>
                </ChildContent>
            </FlyoutMenu>
        </FlexLayout>
    </GridItem>
</Grid>

@code {
    public List<PdfDocument> Files { get; set; } = [];
    private HashSet<PdfPage> SelectedPages { get; set; } = new();

    protected override void OnInitialized()
    {
        if (DataNavigationService.TryGetData<PdfDocument[]>("files", out var files) && files?.Length > 0)
        {
            Files.AddRange(files);
        }
    }

    private void RemoveFile(PdfDocument model)
    {
        if (!Files.Contains(model)) return;
        Files.Remove(model);
        StateHasChanged();
    }

    private async void FileAdded(IBrowserFile[] files)
    {
        using (BusyTracker.Track("FileAdded", StateHasChanged))
        {
            var loadTasks = files.Select(file => Task.Run(file.LoadPdfDocument));
            var loadedFiles = await Task.WhenAll(loadTasks);
            Files.AddRange(loadedFiles);
            Logger.LogDebug($"Added {files.Length} files to editor");
            StateHasChanged();
        }
    }

    private void MovePagesToFile(PdfDocument file, params PdfPage[] pages)
    {
        foreach(var page in pages)
        {
            var addedPage = file.AddPage(page);
            addedPage.Tag = page.GetOrAssignId(); // Reassign the tag to maintain ID consistency

            // Remove the page from the original document
            var originalDocument = page.Owner;
            if (originalDocument != null)
            {
                originalDocument.Pages.Remove(page);
                if (originalDocument.PageCount == 0)
                {
                    Files.Remove(originalDocument);
                }
            }

            Logger.LogDebug($"Page moved to file: {page} -> {file}");
        }

        StateHasChanged();
    }

    private void RemovePageFromFile(PdfDocument doc, PdfPage page)
    {
        doc.Pages.Remove(page);
        StateHasChanged();
    }

    private void MovePagesToNewFile(params PdfPage[] pages)
    {
        // Create a new empty PDF document
        var doc = new PdfDocument();
        doc.Info.Title = "New Document";

        // We'll map old tags to maintain IDs
        var pageTags = new List<string>();

        // Add the pages to the new document
        foreach(var page in pages)
        {
            pageTags.Add(page.GetOrAssignId()); // store tag/id it for later reassignment

            var importedPage = doc.AddPage(page, AnnotationCopyingType.DeepCopy);
            var originalDocument = page.Owner;
            if (originalDocument != null)
            {
                // Remove the page from the original document
                originalDocument.Pages.Remove(page);
                if (originalDocument.PageCount == 0)
                {
                    Files.Remove(originalDocument);
                }
            }

            Logger.LogDebug($"Page moved to new file: {page}");
        }

        // Save the document to a memory stream
        using var memoryStream = new MemoryStream();
        doc.Save(memoryStream, false); // Save the document to the stream
        memoryStream.Position = 0; // Reset the stream position

        // Reopen the document in Import mode (if needed for further operations)
        var importedDoc = PdfReader.Open(memoryStream, PdfDocumentOpenMode.Import);
        Console.WriteLine(importedDoc.Pages[0].Tag);

        // Re-assign the tags in same order
        for (int i = 0; i < importedDoc.PageCount && i < pageTags.Count; i++)
        {
            importedDoc.Pages[i].Tag = pageTags[i];
        }

        Files.Add(importedDoc);
        SelectedPages.Clear();
        StateHasChanged();
    }

    private void MovePageToFileAtIndex(PdfDocument file, int index, params PdfPage[] pages)
    {
        foreach(var page in pages)
        {
            var pageCount = file.PageCount;
            if (index < 0 || index > pageCount)
            {
                Logger.LogWarning($"Invalid index {index} for MovePageToFileAtIndex. Clamping...");
                index = Math.Clamp(index, 0, pageCount);
            }

            if (page.Owner == file)
            {
                // Moving within the same file
                var currentIndex = file.Pages.GetPageIndex(page);
                if (currentIndex == index || currentIndex == index - 1)
                    return;

                file.Pages.MovePage(currentIndex, index);
            }
            else
            {
                // Moving from a different file
                file.Pages.Insert(index, page);
                var originalDoc = page.Owner;
                originalDoc?.Pages.Remove(page);
                if (originalDoc?.PageCount == 0)
                {
                    Files.Remove(originalDoc);
                }
            }

            Logger.LogDebug($"Page moved to file at index {index}: {page} -> {file}");
        }

        SelectedPages.Clear();
        StateHasChanged();
    }

    private bool CanSplit => Files.Count > 0 && Files.Any(doc => doc.PageCount > 1);
    private void SplitAll()
    {
        if (!CanSplit) return;
        // Create a copy of the Files collection to iterate over
        var filesCopy = Files.ToList();

        foreach (var file in filesCopy)
        {
            for (int i = 0; i < file.PageCount; i++)
            {
                var page = file.Pages[i];
                MovePagesToNewFile(page);
            }
        }
    }

    private bool CanMerge => Files.Count > 1;
    private void MergeAll()
    {
        if (!CanMerge) return;

        var doc = Files.First();
        // Create a copy of the Files collection to iterate over
        var filesCopy = Files.ToList();
        foreach (var file in filesCopy.Skip(1))
        {
            for(var i = 0; i < file.PageCount; i++)
            {
                var page = file.Pages[i];
                MovePagesToFile(doc, page);
            }
        }
    }

    private void ToggleSelection(PdfPage page)
    {
        if (SelectedPages.Contains(page))
            SelectedPages.Remove(page);
        else
            SelectedPages.Add(page);
    }

    private void ShowFullscren(PdfPage page)
    {
        DialogService.ShowAsync<PdfViewerDialog>(page.Owner.Info.Title, new() { [nameof(PdfViewerDialog.Pages)] = page.Owner.Pages, [nameof(PdfViewerDialog.PageIndex)] = page.Owner.GetPageIndex(page) });
    }
}